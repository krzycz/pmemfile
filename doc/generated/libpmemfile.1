.\" Automatically generated by Pandoc 1.16.0.2
.\"
.TH "pmemfile" "1" "pmemfile API version 0.1.0" "" "" ""
.hy
.\" Copyright 2016-2017, Intel Corporation
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\"
.\"     * Redistributions of source code must retain the above copyright
.\"       notice, this list of conditions and the following disclaimer.
.\"
.\"     * Redistributions in binary form must reproduce the above copyright
.\"       notice, this list of conditions and the following disclaimer in
.\"       the documentation and/or other materials provided with the
.\"       distribution.
.\"
.\"     * Neither the name of the copyright holder nor the names of its
.\"       contributors may be used to endorse or promote products derived
.\"       from this software without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
.\" "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
.\" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
.\" A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
.\" OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
.\" SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
.\" LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
.\" OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.SH NAME
.PP
\f[B]Pmemfile\f[] \- persistent memory file system.
.SH SYNOPSIS
.IP
.nf
\f[C]
export\ LD_PRELOAD=libpmemfile.so
\f[]
.fi
.PP
\f[B]or\f[]
.IP
.nf
\f[C]
LD_PRELOAD=libpmemfile.so\ <invoke\ application\ via\ cli>
\f[]
.fi
.SH DESCRIPTION
.PP
\f[B]Pmemfile\f[] is a user space transactional persistent memory file
system which is automatically enabled for an application when the
\f[B]libpmemfile\f[] library is pre\-loaded into the application
environment as shown in the \f[B]SYNOPSIS\f[] section.
\f[B]Pmemfile\f[] provides applications nearly transparent direct access
to persistent memory resident files.
\f[B]Pmemfile\f[], when enabled as described, provides intercept points
for the standard Linux glibc interfaces.
There are some exceptions to the standard glibc behavior with
\f[B]Pmemfile\f[] and these are described in this man page.
.SH EXCEPTIONS TO POSIX SUPPORT
.PP
This section outlines the exceptions to the specified file operations.
.SH MULTI\-PROCESS SUPPORT
.PP
The NVM library \f[B]libpmemobj\f[] does not provide multi\-process
support.
\f[B]libpmemfile\f[] is built upon \f[B]libpmemobj\f[] so therefore
\f[B]Pmemfile\f[] does not provide multi\-process support.
.IP
.nf
\f[C]
int\ clone(int\ (*fn)(void\ *),\ void\ *child_stack,
\ \ \ \ int\ flags,\ void\ *arg,\ ...
\ \ \ \ /*\ pid_t\ *ptid,\ struct\ user_desc\ *tls,\ pid_t\ *ctid\ */);
pid_t\ fork(void);
pid_t\ vfork(void);
\f[]
.fi
.SS clone
.PP
Is supported with the following flag exceptions:
.IP
.nf
\f[C]
CLONE_IO
\ \ \ \ Not\ supported.

CLONE_NEWNET
\ \ \ \ Not\ supported.

CLONE_NEWNS
\ \ \ \ Not\ supported.

CLONE_NEWUTS
\ \ \ \ Not\ supported.

CLONE_NEWPID
\ \ \ \ Not\ supported.

CLONE_PARENT
\ \ \ \ Not\ supported.

CLONE_PID
\ \ \ \ Not\ supported.\ Obsolete.

CLONE_VFORK
\ \ \ \ Not\ supported.

CLONE_VM
\ \ \ \ Is\ supported.\ However,\ even\ if\ a\ thread\ is\ created\ with\ shared
\ \ \ \ virtual\ memory\ the\ child\ will\ not\ be\ able\ to\ access,\ create\ or
\ \ \ \ modify\ any\ pmem\-resident\ files.
\f[]
.fi
.PP
\f[I]RETURN VALUE\f[]
.IP
.nf
\f[C]
\-1\ in\ the\ case\ of\ the\ unsupported\ flags.\ Otherwise,\ as\ defined\ in\ the
clone(2)\ manpage.
\f[]
.fi
.PP
\f[I]ERRORS\f[]
.IP
.nf
\f[C]
EINVAL\ in\ the\ case\ of\ unsupported\ flags.\ \ Otherwise,\ as\ defined\ in
the\ clone(2)\ manpage.
\f[]
.fi
.SS fork
.PP
A child created with fork() will not be allowed to access any of the
existing pmem\-resident files nor create new ones.
.PP
\f[I]RETURN VALUE\f[]
.IP
.nf
\f[C]
As\ defined\ in\ the\ fork()\ manpage.
\f[]
.fi
.PP
\f[I]ERRORS\f[]
.IP
.nf
\f[C]
As\ defined\ in\ the\ fork()\ manpage.
\f[]
.fi
.SS vfork
.PP
Not supported.
.PP
\f[I]RETURN VALUE\f[]
.IP
.nf
\f[C]
\-1
\f[]
.fi
.PP
\f[I]ERRORS\f[]
.IP
.nf
\f[C]
ENOSYS\ Not\ supported\ on\ this\ platform.
\f[]
.fi
.SH I/O EVENT NOTIFICATION
.PP
I/O event notification is not supported, which includes the following
system calls:
.IP
.nf
\f[C]
int\ epoll_ctl(int\ epfd,\ intop,\ intfd,\ struct\ epoll_event\ *event);
int\ epoll_wait(int\ epfd,\ struct\ epoll_event\ *events,
\ \ \ \ \ \ \ \ int\ maxevents,\ int\ timeout);
int\ epoll_pwait(int\ epfd,\ struct\ epoll_event\ *events,
\ \ \ \ \ \ \ \ int\ maxevents,\ int\ timeout,\ const\ sigset_t\ *sigmask);
int\ fanotify_mark(int\ fanotify_fd,\ unsigned\ int\ flags,
\ \ \ \ \ \ \ \ int\ dirfd,\ const\ char\ *\ pathname);
int\ inotify_add_watch(int\ fd,\ const\ char\ *pathname,\ uint32_t\ mask);
int\ inotify_rm_watch(int\ fd,\ int\ wd);
int\ poll(struct\ pollfd\ *fds,\ nfds_t\ nfds,\ int\ timeout);
int\ ppoll(struct\ pollfd\ *fds,\ nfds_t\ nfds,
\ \ \ \ \ \ \ \ const\ struct\ timespec\ *timeout_ts,\ const\ sigset_t\ *sigmask);
int\ select(int\ nfds,\ fd_set\ *readfds,\ fd_set\ *writefds,
\ \ \ \ \ \ \ \ fd_set\ *exceptfds,\ struct\ timeval\ *timeout);
int\ pselect(int\ nfds,\ fd_set\ *readfds,\ fd_set\ *writefds,
\ \ \ \ \ \ \ \ fd_set\ *\ exceptfds,\ const\ struct\ timespec\ *\ timeout,
\ \ \ \ \ \ \ \ const\ sigset_t\ *\ sigmask);
\f[]
.fi
.PP
\f[I]RETURN VALUE\f[]
.IP
.nf
\f[C]
\-1
\f[]
.fi
.PP
\f[I]ERRORS\f[]
.IP
.nf
\f[C]
EBADF\ in\ all\ cases.
\f[]
.fi
.SH PROGRAM EXECUTION
.PP
Execution of a program is not supported when the executable file is a
pmem\-resident file.
.IP
.nf
\f[C]
int\ execve(const\ char\ *filename,\ char\ *\ const\ argv[],\ char\ *const\ envp[]);
\f[]
.fi
.PP
\f[I]RETURN VALUE\f[]
.IP
.nf
\f[C]
\-1\ on\ error.\ On\ success,\ execve(2)\ does\ not\ return.
\f[]
.fi
.PP
\f[I]ERRORS\f[]
.IP
.nf
\f[C]
EACCESS\ Execute\ permission\ is\ denied\ for\ pmem\ resident\ files.\ Otherwise
as\ defined\ in\ the\ execve()\ manpage.
\f[]
.fi
.SH EXTENEDED ATTRIBUTES
.PP
\f[B]Pmemfile\f[] does not support extended attributes.
The following system calls are not supported.
.IP
.nf
\f[C]
ssize_t\ lgetxattr(const\ char\ *path,\ const\ char\ *name,\ void\ \ *value,
\ \ \ \ \ \ \ \ size_t\ size);
ssize_t\ fgetxattr(intfd,\ const\ char\ *name,\ void\ *value,\ size_t\ size);
ssize_t\ listxattr(const\ char\ *path,\ char\ *list,\ size_t\ size);
ssize_t\ llistxattr(const\ char\ *path,\ char\ *list,\ size_t\ size);
ssize_t\ flistxattr(int\ fd,\ char\ *list,\ size_t\ size);
int\ setxattr(const\ char\ *path,\ const\ char\ *name,\ const\ void\ *value,
\ \ \ \ \ \ \ \ size_t\ size,\ int\ flags);
int\ lsetxattr(const\ char\ *path,\ const\ char\ *name,\ const\ void\ *value,
\ \ \ \ \ \ \ \ size_t\ size,\ int\ flags);
int\ fsetxattr(int\ fd,\ const\ char\ *name,\ const\ void\ *value,\ size_t\ size,
\ \ \ \ \ \ \ \ int\ flags);
\f[]
.fi
.PP
\f[I]RETURN VALUE\f[]
.IP
.nf
\f[C]
\-1
\f[]
.fi
.PP
\f[I]ERRORS\f[]
.IP
.nf
\f[C]
ENOTSUP\ Not\ supported.
\f[]
.fi
.SH FLUSHING
.PP
All writes are synchronous with persistent memory therefore
\f[B]Pmemfile\f[] supports only synchronous writes.
All calls to to any of the functions below will return success except in
the case of a bad file descriptor.
.IP
.nf
\f[C]
void\ sync(void);
int\ sync_file_range(int\ fd,\ off64_t\ offset,\ off64_t\ nbytes,
\ \ \ \ \ \ \ \ unsigned\ int\ flags);
int\ syncfs(int\ fd);
int\ fsync(int\ fd);
int\ fdatasync(int\ fd);
\f[]
.fi
.PP
\f[I]RETURN VALUE\f[]
.IP
.nf
\f[C]
0\ or\ \-1
\f[]
.fi
.PP
\f[I]ERRORS\f[]
.IP
.nf
\f[C]
As\ per\ manpage.
\f[]
.fi
.SH SPECIAL FILES
.PP
The system calls that manage block or character special files are not
supported when pathname points to a pmemfile\-backed file system.
.IP
.nf
\f[C]
int\ mknod(const\ char\ *pathname,\ mode_t\ mode,\ dev_t\ dev);
int\ mknodat(int\ dirfd,\ const\ char\ *pathname,\ mode_t\ mode,\ dev_t\ dev);
\f[]
.fi
.PP
\f[I]RETURN VALUE\f[]
.IP
.nf
\f[C]
\-1
\f[]
.fi
.PP
\f[I]ERRORS\f[]
.IP
.nf
\f[C]
EACCESS\ No\ write\ permission.
\f[]
.fi
.SH MEMORY MAPPING
.PP
Memory mapping is not supported.
.IP
.nf
\f[C]
void\ *mmap(void\ *addr,\ size_t\ length,\ int\ prot,\ int\ flags,
\ \ \ \ \ \ \ \ \ \ \ int\ fd,\ off_t\ offset);
\f[]
.fi
.PP
\f[I]RETURN VALUE\f[]
.IP
.nf
\f[C]
\-1
\f[]
.fi
.PP
\f[I]ERRORS\f[]
.IP
.nf
\f[C]
ENODEV\ The\ underlying\ file\ system\ of\ the\ specified\ file\ does\ not\ support
memory\ mapping.
\f[]
.fi
.SH FILE MANAGEMENT
.PP
The open/at() and creat() system calls are supported.
Noted in this section are the flags and mode bits that are not supported
or have modified behavior.
.IP
.nf
\f[C]
int\ open(const\ char\ *pathname,\ int\ flags);
int\ open(const\ char\ *pathname,\ int\ flags,\ mode_t\ mode);
int\ creat(const\ char*\ pathname,\ mode_t\ mode);
int\ openat(int\ dirfd,\ const\ char\ *\ pathname,\ int\ flags);
int\ openat(int\ dirfd,\ const\ char\ *\ pathname,\ int\ flags,\ mode_t\ mode);
\f[]
.fi
.SS Flags and Mode Bits
.IP
.nf
\f[C]
O_ASYNC
\ \ \ \ Not\ supported.

O_CLOEXEC
\ \ \ \ This\ flag\ is\ always\ set

O_DIRECT
\ \ \ \ This\ flag\ is\ ignored.

O_NONBLOCK\ or\ O_NDELAY
\ \ \ \ These\ flags\ are\ ignored.

O_NOCTTY
\ \ \ \ Not\ supported.

O_PATH
\ \ \ \ This\ flag\ will\ behave\ the\ same\ as\ is\ documented\ in\ the\ open(2)\ manpage.
\ \ \ \ However,\ the\ use\ of\ the\ file\ descriptor\ returned\ as\ a\ result\ of\ this\ flag
\ \ \ \ cannot\ be\ used\ to\ pass\ to\ another\ process\ via\ a\ UNIX\ domain\ socket.\ **Pmemfile**
\ \ \ \ does\ not\ provide\ UNIX\ socket\ support.

O_SYNC,\ O_DSYNC
\ \ \ \ These\ flags\ are\ ignored.
\f[]
.fi
.PP
All mode flags are supported.
.PP
\f[I]RETURN VALUE\f[]
.IP
.nf
\f[C]
\-1\ in\ the\ case\ of\ the\ unsupported\ flags.\ Otherwise\ as\ defined\ in\ the\ open(2)\ manpage.
\f[]
.fi
.PP
\f[I]ERRORS\f[]
.IP
.nf
\f[C]
EINVAL\ in\ the\ case\ of\ unsupported\ flags.\ Otherwise\ as\ defined\ in\ the\ open(2)\ manpage.
\f[]
.fi
.SH FILE LOCKING
.PP
File locking is not supported.
.IP
.nf
\f[C]
int\ flock(int\ fd,\ int\ operation);
\f[]
.fi
.PP
\f[I]RETURN VALUE\f[]
.IP
.nf
\f[C]
\-1
\f[]
.fi
.PP
\f[I]ERRORS\f[]
.IP
.nf
\f[C]
EINVAL\ Operation\ is\ invalid.
\f[]
.fi
.SH FILE DESCRIPTOR MANAGEMENT
.PP
Is supported with the following exceptions.
.IP
.nf
\f[C]
int\ fcntl(int\ fd,\ int\ cmd,\ ...\ /*\ arg\ */\ );
\f[]
.fi
.SS Duplicating File Descriptors
.IP
.nf
\f[C]
F_DUPFD_CLOEXEC
\ \ \ \ Pmemfile\ always\ sets\ this\ flag\ for\ every\ file.\ Setting\ it\ is\ a\ no\-op.
\f[]
.fi
.SS File Descriptor Flags
.IP
.nf
\f[C]
F_SETFD
\ \ \ \ Is\ supported.\ Currently,\ the\ only\ flag\ supported\ is\ O_CLOEXEC\ as\ it\ is\ always
\ \ \ \ set.
\f[]
.fi
.SS File Status
.IP
.nf
\f[C]
F_SETFL
\ \ \ \ Is\ supported\ as\ follows:
\ \ \ \ O_ASYNC
\ \ \ \ \ \ \ \ Never

\ \ \ \ O_DIRECT
\ \ \ \ \ \ \ \ Always

\ \ \ \ O_NONBLOCK
\ \ \ \ \ \ \ \ Ignored
\f[]
.fi
.PP
\f[I]RETURN VALUE\f[]
.IP
.nf
\f[C]
0\ for\ cases\ noted\ above.\ Otherwise\ as\ defined\ in\ the\ fcntl(2)\ manpage.
\f[]
.fi
.PP
\f[I]ERRORS\f[]
.IP
.nf
\f[C]
As\ defined\ in\ the\ fcntl(2)\ manpage.
\f[]
.fi
.SS Locking
.IP
.nf
\f[C]
F_SETLK,\ F_SETLKW,\ F_GETLK
\ \ \ \ Not\ supported.

F_SETOWN,\ F_GETOWN_EX,\ F_SETOWN_EX
\ \ \ \ Not\ supported.

F_GETSIG,\ F_SETSIG
\ \ \ \ Not\ supported.

F_SETLEASE,\ F_GETLEASE
\ \ \ \ Not\ supported.

F_NOTIFY
\ \ \ \ Not\ supported.
\f[]
.fi
.PP
\f[B]Mandatory Locks\f[]
.PP
Are Not Supported
.PP
\f[I]RETURN VALUE\f[]
.IP
.nf
\f[C]
\-1\ for\ all\ flags\ not\ supported.\ Otherwise\ as\ defined\ in\ the\ fcntl()\ manpage.
\f[]
.fi
.PP
\f[I]ERRORS\f[]
.IP
.nf
\f[C]
**EINVAL**\ for\ flags\ noted\ as\ not\ supported.\ Otherwise\ as\ defined\ in\ the\ fcntl()\ manpage.
\f[]
.fi
.SH DUPLICATION OF FILE DESCRIPTORS
.PP
Duplication of file descriptors is supported.
.IP
.nf
\f[C]
int\ dup(int\ oldfd);
int\ dup2(int\ oldfd,\ int\ newfd);
int\ dup3(int\ oldfd,\ int\ newfd,\ int\ flags);
\f[]
.fi
.PP
dup3() Allows the user to force the setting of the O_CLOEXEC flag.
This flag is always set with \f[B]Pmemfile\f[] so setting of this flag
with dup3() is a no\-op.
.PP
\f[I]RETURN VALUE\f[]
.IP
.nf
\f[C]
As\ specified\ in\ the\ manpage.
\f[]
.fi
.PP
\f[I]ERRORS\f[]
.IP
.nf
\f[C]
As\ specified\ in\ the\ manpage.
\f[]
.fi
.SH READAHEAD
.PP
Is not supported.
\f[B]Pmemfile\f[] does not support caching as it always operates in
direct access mode.
.IP
.nf
\f[C]
ssize_t\ readahead(int\ fd,\ off64_t\ offset,\ size_t\ count);
\f[]
.fi
.PP
\f[I]RETURN VALUE\f[]
.IP
.nf
\f[C]
\-1
\f[]
.fi
.PP
\f[I]ERRORS\f[]
.IP
.nf
\f[C]
EINVAL\ fd\ does\ not\ refer\ to\ a\ file\ type\ to\ which\ readahead\ can\ be\ applied.
\f[]
.fi
.SH RENAME
.PP
All renameX() functions are supported as long as the old and new files
are within the same \f[B]Pmemfile\f[] pool.
For:
.IP
.nf
\f[C]
int\ renameat2(int\ olddirfd,\ const\ char\ *oldpath,
\ \ \ \ \ \ \ \ \ \ int\ newdirfd,\ const\ char\ *newpath,\ unsigned\ int\ flags);
\f[]
.fi
.PP
The following flag are not supported:
.IP
.nf
\f[C]
RENAME_WHITEOUT
\f[]
.fi
.PP
\f[I]RETURN VALUE\f[]
.IP
.nf
\f[C]
\-1\ For\ the\ error\ case\ specified\ above.\ Otherwise\ as\ defined\ in\ the\ respective\ manpage.
\f[]
.fi
.PP
\f[I]ERRORS\f[]
.IP
.nf
\f[C]
EINVAL\ for\ renameat2()\ flag\ RENAME_WITEHOUT.\ Otherwise,
As\ defined\ in\ the\ respective\ manpage.
\f[]
.fi
.SH ASYNCHRONOUS I/O
.PP
\f[B]Pmemfile\f[] does not support POSIX asynchronous I/O.
.SH MISCELLANEOUS OPERATIONS
.IP
.nf
\f[C]
int\ chroot(const\ char\ *path);
int\ ioctl(int\ d,\ int\ request,...);
int\ pivot_root(const\ char\ *new_root,\ const\ char*\ put_old);
int\ swapon(const\ char\ *path,\ int\ swapflags);
int\ swapoff(const\ char\ *path);
int\ fadvisa64(int\ fd,\ off_t\ offset,\ off_t\ len,\ int\ advice);
\f[]
.fi
.PP
Are not supported.
.PP
\f[I]RETURN VALUE\f[]
.IP
.nf
\f[C]
\-1
\f[]
.fi
.PP
\f[I]ERRORS\f[]
.IP
.nf
\f[C]
chroot()
\ \ \ \ EPERM\ Insufficient\ privilege.

ioctl()
\ \ \ \ EFAULT\ Requesting\ an\ inaccessible\ memory\ area.

pivot\\_root()
\ \ \ \ EPERM\ Insufficient\ privilege.

swapon(),\ swapoff()
\ \ \ \ EINVAL\ Invalid\ Path

fadvise64()
\ \ \ \ EBADF
\f[]
.fi
