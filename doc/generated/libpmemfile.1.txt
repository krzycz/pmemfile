pmemfile(1)                                                             pmemfile(1)

NAME
       Pmemfile - persistent memory file system.

SYNOPSIS
              export LD_PRELOAD=libpmemfile.so

       or

              LD_PRELOAD=libpmemfile.so <invoke application via cli>

DESCRIPTION
       Pmemfile  is  a user space transactional persistent memory file system which
       is automatically enabled for an application when the libpmemfile library  is
       pre-loaded  into  the  application environment as shown in the SYNOPSIS sec‐
       tion.  Pmemfile provides applications nearly transparent  direct  access  to
       persistent memory resident files.  Pmemfile, when enabled as described, pro‐
       vides intercept points for the standard Linux glibc interfaces.   There  are
       some  exceptions  to the standard glibc behavior with Pmemfile and these are
       described in this man page.

EXCEPTIONS TO POSIX SUPPORT
       This section outlines the exceptions to the specified file operations.

MULTI-PROCESS SUPPORT
       The NVM library libpmemobj does not provide multi-process support.  libpmem‐
       file  is  built  upon libpmemobj so therefore Pmemfile does not provide mul‐
       ti-process support.

              int clone(int (*fn)(void *), void *child_stack,
                  int flags, void *arg, ...
                  /* pid_t *ptid, struct user_desc *tls, pid_t *ctid */);
              pid_t fork(void);
              pid_t vfork(void);

   clone
       Is supported with the following flag exceptions:

              CLONE_IO
                  Not supported.

              CLONE_NEWNET
                  Not supported.

              CLONE_NEWNS
                  Not supported.

              CLONE_NEWUTS
                  Not supported.

              CLONE_NEWPID
                  Not supported.

              CLONE_PARENT
                  Not supported.

              CLONE_PID
                  Not supported. Obsolete.

              CLONE_VFORK
                  Not supported.

              CLONE_VM
                  Is supported. However, even if a thread is created with shared
                  virtual memory the child will not be able to access, create or
                  modify any pmem-resident files.

       RETURN VALUE

              -1 in the case of the unsupported flags. Otherwise, as defined in the
              clone(2) manpage.

       ERRORS

              EINVAL in the case of unsupported flags.  Otherwise, as defined in
              the clone(2) manpage.

   fork
       A child created with fork() will not be allowed to access any of the  exist‐
       ing pmem-resident files nor create new ones.

       RETURN VALUE

              As defined in the fork() manpage.

       ERRORS

              As defined in the fork() manpage.

   vfork
       Not supported.

       RETURN VALUE

              -1

       ERRORS

              ENOSYS Not supported on this platform.

I/O EVENT NOTIFICATION
       I/O event notification is not supported, which includes the following system
       calls:

              int epoll_ctl(int epfd, intop, intfd, struct epoll_event *event);
              int epoll_wait(int epfd, struct epoll_event *events,
                      int maxevents, int timeout);
              int epoll_pwait(int epfd, struct epoll_event *events,
                      int maxevents, int timeout, const sigset_t *sigmask);
              int fanotify_mark(int fanotify_fd, unsigned int flags,
                      int dirfd, const char * pathname);
              int inotify_add_watch(int fd, const char *pathname, uint32_t mask);
              int inotify_rm_watch(int fd, int wd);
              int poll(struct pollfd *fds, nfds_t nfds, int timeout);
              int ppoll(struct pollfd *fds, nfds_t nfds,
                      const struct timespec *timeout_ts, const sigset_t *sigmask);
              int select(int nfds, fd_set *readfds, fd_set *writefds,
                      fd_set *exceptfds, struct timeval *timeout);
              int pselect(int nfds, fd_set *readfds, fd_set *writefds,
                      fd_set * exceptfds, const struct timespec * timeout,
                      const sigset_t * sigmask);

       RETURN VALUE

              -1

       ERRORS

              EBADF in all cases.

PROGRAM EXECUTION
       Execution of a program is not  supported  when  the  executable  file  is  a
       pmem-resident file.

              int execve(const char *filename, char * const argv[], char *const envp[]);

       RETURN VALUE

              -1 on error. On success, execve(2) does not return.

       ERRORS

              EACCESS Execute permission is denied for pmem resident files. Otherwise
              as defined in the execve() manpage.

EXTENEDED ATTRIBUTES
       Pmemfile  does  not support extended attributes.  The following system calls
       are not supported.

              ssize_t lgetxattr(const char *path, const char *name, void  *value,
                      size_t size);
              ssize_t fgetxattr(intfd, const char *name, void *value, size_t size);
              ssize_t listxattr(const char *path, char *list, size_t size);
              ssize_t llistxattr(const char *path, char *list, size_t size);
              ssize_t flistxattr(int fd, char *list, size_t size);
              int setxattr(const char *path, const char *name, const void *value,
                      size_t size, int flags);
              int lsetxattr(const char *path, const char *name, const void *value,
                      size_t size, int flags);
              int fsetxattr(int fd, const char *name, const void *value, size_t size,
                      int flags);

       RETURN VALUE

              -1

       ERRORS

              ENOTSUP Not supported.

FLUSHING
       All writes are synchronous with persistent memory  therefore  Pmemfile  sup‐
       ports  only  synchronous writes.  All calls to to any of the functions below
       will return success except in the case of a bad file descriptor.

              void sync(void);
              int sync_file_range(int fd, off64_t offset, off64_t nbytes,
                      unsigned int flags);
              int syncfs(int fd);
              int fsync(int fd);
              int fdatasync(int fd);

       RETURN VALUE

              0 or -1

       ERRORS

              As per manpage.

SPECIAL FILES
       The system calls that manage block or character special files are  not  sup‐
       ported when pathname points to a pmemfile-backed file system.

              int mknod(const char *pathname, mode_t mode, dev_t dev);
              int mknodat(int dirfd, const char *pathname, mode_t mode, dev_t dev);

       RETURN VALUE

              -1

       ERRORS

              EACCESS No write permission.

MEMORY MAPPING
       Memory mapping is not supported.

              void *mmap(void *addr, size_t length, int prot, int flags,
                         int fd, off_t offset);

       RETURN VALUE

              -1

       ERRORS

              ENODEV The underlying file system of the specified file does not support
              memory mapping.

FILE MANAGEMENT
       The open/at() and creat() system calls are supported.  Noted in this section
       are the flags and mode bits that are not supported or have  modified  behav‐
       ior.

              int open(const char *pathname, int flags);
              int open(const char *pathname, int flags, mode_t mode);
              int creat(const char* pathname, mode_t mode);
              int openat(int dirfd, const char * pathname, int flags);
              int openat(int dirfd, const char * pathname, int flags, mode_t mode);

   Flags and Mode Bits
              O_ASYNC
                  Not supported.

              O_CLOEXEC
                  This flag is always set

              O_DIRECT
                  This flag is ignored.

              O_NONBLOCK or O_NDELAY
                  These flags are ignored.

              O_NOCTTY
                  Not supported.

              O_PATH
                  This flag will behave the same as is documented in the open(2) manpage.
                  However, the use of the file descriptor returned as a result of this flag
                  cannot be used to pass to another process via a UNIX domain socket. **Pmemfile**
                  does not provide UNIX socket support.

              O_SYNC, O_DSYNC
                  These flags are ignored.

       All mode flags are supported.

       RETURN VALUE

              -1 in the case of the unsupported flags. Otherwise as defined in the open(2) manpage.

       ERRORS

              EINVAL in the case of unsupported flags. Otherwise as defined in the open(2) manpage.

FILE LOCKING
       File locking is not supported.

              int flock(int fd, int operation);

       RETURN VALUE

              -1

       ERRORS

              EINVAL Operation is invalid.

FILE DESCRIPTOR MANAGEMENT
       Is supported with the following exceptions.

              int fcntl(int fd, int cmd, ... /* arg */ );

   Duplicating File Descriptors
              F_DUPFD_CLOEXEC
                  Pmemfile always sets this flag for every file. Setting it is a no-op.

   File Descriptor Flags
              F_SETFD
                  Is supported. Currently, the only flag supported is O_CLOEXEC as it is always
                  set.

   File Status
              F_SETFL
                  Is supported as follows:
                  O_ASYNC
                      Never

                  O_DIRECT
                      Always

                  O_NONBLOCK
                      Ignored

       RETURN VALUE

              0 for cases noted above. Otherwise as defined in the fcntl(2) manpage.

       ERRORS

              As defined in the fcntl(2) manpage.

   Locking
              F_SETLK, F_SETLKW, F_GETLK
                  Not supported.

              F_SETOWN, F_GETOWN_EX, F_SETOWN_EX
                  Not supported.

              F_GETSIG, F_SETSIG
                  Not supported.

              F_SETLEASE, F_GETLEASE
                  Not supported.

              F_NOTIFY
                  Not supported.

       Mandatory Locks

       Are Not Supported

       RETURN VALUE

              -1 for all flags not supported. Otherwise as defined in the fcntl() manpage.

       ERRORS

              **EINVAL** for flags noted as not supported. Otherwise as defined in the fcntl() manpage.

DUPLICATION OF FILE DESCRIPTORS
       Duplication of file descriptors is supported.

              int dup(int oldfd);
              int dup2(int oldfd, int newfd);
              int dup3(int oldfd, int newfd, int flags);

       dup3()  Allows  the  user  to force the setting of the O_CLOEXEC flag.  This
       flag is always set with Pmemfile so setting of this flag with  dup3()  is  a
       no-op.

       RETURN VALUE

              As specified in the manpage.

       ERRORS

              As specified in the manpage.

READAHEAD
       Is  not  supported.  Pmemfile does not support caching as it always operates
       in direct access mode.

              ssize_t readahead(int fd, off64_t offset, size_t count);

       RETURN VALUE

              -1

       ERRORS

              EINVAL fd does not refer to a file type to which readahead can be applied.

RENAME
       All renameX() functions are supported as long as the old and new  files  are
       within the same Pmemfile pool.  For:

              int renameat2(int olddirfd, const char *oldpath,
                        int newdirfd, const char *newpath, unsigned int flags);

       The following flag are not supported:

              RENAME_WHITEOUT

       RETURN VALUE

              -1 For the error case specified above. Otherwise as defined in the respective manpage.

       ERRORS

              EINVAL for renameat2() flag RENAME_WITEHOUT. Otherwise,
              As defined in the respective manpage.

ASYNCHRONOUS I/O
       Pmemfile does not support POSIX asynchronous I/O.

MISCELLANEOUS OPERATIONS
              int chroot(const char *path);
              int ioctl(int d, int request,...);
              int pivot_root(const char *new_root, const char* put_old);
              int swapon(const char *path, int swapflags);
              int swapoff(const char *path);
              int fadvisa64(int fd, off_t offset, off_t len, int advice);

       Are not supported.

       RETURN VALUE

              -1

       ERRORS

              chroot()
                  EPERM Insufficient privilege.

              ioctl()
                  EFAULT Requesting an inaccessible memory area.

              pivot\_root()
                  EPERM Insufficient privilege.

              swapon(), swapoff()
                  EINVAL Invalid Path

              fadvise64()
                  EBADF

                             pmemfile API version 0.1.0                 pmemfile(1)
